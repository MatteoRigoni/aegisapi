# ADR-002: Policy Engine — OPA/Rego

## Context
We require central, auditable authorization and request governance (RBAC/ABAC, tenancy, resource scoping, rate limit entitlements, schema gates) with fast decisions and GitOps workflows.

## Decision
Use **OPA** with **Rego** policies packaged as **bundles** (OCI). Run **OPA sidecar** next to the YARP gateway. YARP middleware queries `/v1/data/aegis/allow` and enforces **deny by default**.

## Alternatives
- Inline C# policy code: faster start, weaker auditability & separation of duties.
- OPA as central service: simpler updates but adds network latency and an HA dependency.
- Proprietary policy engines.

## Consequences
- Strong separation of policy vs code; easy PR reviews; testable with policy unit tests.
- Requires bundle lifecycle (publish, sign, distribute) and version pinning.

## Security Impact
- Fail-closed with local cache; signed bundles; strict input sanitization to OPA (no secrets).
- Policy evaluation inputs must exclude PII or be minimized.

## Assumptions
- Policy authorship handled by a small, trained group with review gates.

## Trade-offs
- Sidecar increases pod footprint; reduces latency & blast radius vs central OPA.

## Acceptance Criteria
- Policy unit tests cover **≥90% rules**.
- Gateway returns **403** when OPA unavailable (no allow without explicit policy).
- Bundles verified via **Cosign** before load.
